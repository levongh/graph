diff --git a/input/input_file.graph b/input/input_file.graph
index 69e896a..4bb76a1 100644
--- a/input/input_file.graph
+++ b/input/input_file.graph
@@ -7,6 +7,6 @@
 6 50   8 20   4 10   
 1 80   3 10   7 20  6 40   
 2 10   6 30    
-2 10   3 50   4 40    
-1 90   4 20   5 30   
+2 10   3 50   4 40 5 30   
+1 90   4 20      
 3 20  
diff --git a/simulated_annealing.cpp b/simulated_annealing.cpp
index ada9962..6ea82a9 100644
--- a/simulated_annealing.cpp
+++ b/simulated_annealing.cpp
@@ -1,5 +1,3 @@
-#include <cmath>
-#include <cstdlib>
 
 #include "simulated_annealing.h"
 #include "graph.h"
@@ -23,6 +21,9 @@ simulated_annealing::simulated_annealing(Graph* G, partition_config config)
     , m_vertex_count{m_graph->get_vertex_count()}
     , m_cut_size{0}
     , m_annealing_type{annealing_type::FAST_ANNEALING}
+    , m_device{}
+    , m_engine{m_device()}
+    , m_distribution{0, m_vertex_count}
     , m_subsets{config.get_partition_count()}
 {
 }
@@ -49,15 +50,16 @@ void simulated_annealing::shedule_annealing()
 
 void simulated_annealing::mutate()
 {
-    int index = std::rand() % (m_vertex_count - 1) + 1;
+    int index = m_distribution(m_engine);
     auto to_move = m_graph->get_vertex(index);
     auto cut_reduction = to_move->moveing_cost();
-    if (cut_reduction < 0) {
+    if (cut_reduction > 0) {
         apply_move(to_move);
         m_cut_size = m_cut_size - cut_reduction;
     } else {
         double p = std::exp((m_cut_size - cut_reduction) / m_temperature);
-        if (std::rand() % 100 < p * 100) {
+        std::uniform_int_distribution<unsigned> dist{0, 100};
+        if (dist(m_engine) < p * 100) {
             apply_move(to_move);
             m_cut_size = m_cut_size - cut_reduction;
         }
diff --git a/simulated_annealing.h b/simulated_annealing.h
index d0755ab..44b5d61 100644
--- a/simulated_annealing.h
+++ b/simulated_annealing.h
@@ -10,6 +10,8 @@
  */
 
 #include <limits>
+#include <random>
+
 #include "partition.h"
 
 class Graph;
@@ -44,5 +46,8 @@ private:
     unsigned int m_vertex_count;
     double m_cut_size;
     annealing_type m_annealing_type;
+    std::random_device m_device;
+    std::mt19937 m_engine;
+    std::uniform_int_distribution<unsigned> m_distribution;
     std::vector<std::vector<Vertex*> > m_subsets;
 };
